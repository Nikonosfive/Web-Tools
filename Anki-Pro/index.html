<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#1c1c1e">
<title>Anki Pro</title>

<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<style>
    :root {
        --bg-color: #1c1c1e;
        --card-bg: #2c2c2e;
        --text-color: #f2f2f7;
        --accent: #0a84ff;
        --danger: #ff453a;
        --mask-color: #ff9f0a;
        --toolbar-height: 80px; /* å°‘ã—é«˜ãã—ã¦æŠ¼ã—ã‚„ã™ã */
    }
    
    * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
    
    body {
        margin: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        overscroll-behavior: none;
        user-select: none;
        -webkit-user-select: none;
    }

    .screen { display: none; width: 100%; height: 100%; flex-direction: column; }
    .screen.active { display: flex; }

    /* --- ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç”»é¢ --- */
    .header {
        padding: 20px 20px 10px 20px;
        background: rgba(44, 44, 46, 0.95);
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #3a3a3c;
        z-index: 10;
        padding-top: max(20px, env(safe-area-inset-top)); /* ãƒãƒƒãƒå¯¾å¿œ */
    }
    .title { font-size: 20px; font-weight: bold; }
    .add-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        cursor: pointer;
    }
    .library-list {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        touch-action: pan-y;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 15px;
        padding-bottom: 100px;
    }
    .lib-item {
        background: var(--card-bg);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
        aspect-ratio: 1;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .lib-thumb {
        flex: 1;
        background-size: cover;
        background-position: center;
    }
    .lib-info {
        padding: 10px;
        font-size: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(0,0,0,0.6);
        backdrop-filter: blur(5px);
    }
    .delete-btn { color: var(--danger); background: none; border: none; font-size: 16px; padding: 5px; }

    /* --- ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ç”»é¢ --- */
    #workspace-container {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: #000;
        cursor: crosshair;
    }
    #canvas-layer {
        position: absolute;
        transform-origin: 0 0;
        top: 0; left: 0;
        will-change: transform;
    }
    #base-image {
        display: block;
        pointer-events: none;
    }
    
    /* ãƒã‚¹ã‚¯ï¼ˆæš—è¨˜ç”¨ã®éš ã—ç®±ï¼‰ */
    .mask-rect {
        position: absolute;
        background-color: var(--mask-color);
        border: 2px solid #fff;
        opacity: 1;
        /* transition: opacity 0.2s; ç§»å‹•æ™‚ã¯transitioné‚ªé­”ãªã®ã§JSåˆ¶å¾¡ã¸ */
        box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .mode-play .mask-rect { cursor: pointer; transition: opacity 0.2s; }
    .mode-play .mask-rect.revealed { opacity: 0.15; }
    
    /* ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼šé¸æŠä¸­ */
    .mode-edit .mask-rect.selected { 
        border-color: var(--accent); 
        background-color: rgba(10, 132, 255, 0.4); 
        z-index: 100;
    }
    
    /* ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ« */
    .resize-handle {
        display: none;
        position: absolute;
        width: 24px;
        height: 24px;
        background: white;
        border: 2px solid var(--accent);
        border-radius: 50%;
        bottom: -12px;
        right: -12px;
        z-index: 101;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    /* é¸æŠä¸­ã®ã¿ãƒãƒ³ãƒ‰ãƒ«è¡¨ç¤º */
    .mode-edit .mask-rect.selected .resize-handle {
        display: block;
    }

    /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
    .toolbar {
        height: var(--toolbar-height);
        background: rgba(44, 44, 46, 0.95);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-top: 1px solid #3a3a3c;
        padding: 0 20px;
        padding-bottom: env(safe-area-inset-bottom);
    }
    .toolbar-center { display: flex; gap: 15px; }
    
    .tool-btn {
        background: rgba(255,255,255,0.1);
        border: none;
        color: var(--text-color);
        font-size: 14px;
        padding: 8px 16px;
        border-radius: 20px;
        min-width: 60px;
    }
    .tool-btn.primary { background: var(--accent); color: white; }
    .tool-btn.active { background: #fff; color: #000; font-weight: bold; }
    .tool-btn.danger { background: rgba(255, 69, 58, 0.2); color: var(--danger); }
    
    #file-input { display: none; }
    
    /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
    #mode-indicator {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 13px;
        pointer-events: none;
        z-index: 100;
        margin-top: env(safe-area-inset-top);
    }
</style>
</head>
<body>

    <div id="screen-library" class="screen active">
        <div class="header">
            <span class="title">æš—è¨˜ã‚·ãƒ¼ãƒˆPro</span>
            <button class="add-btn" onclick="document.getElementById('file-input').click()">ï¼‹ æ–°è¦ä½œæˆ</button>
        </div>
        <div class="library-list" id="library-list">
            </div>
    </div>

    <div id="screen-workspace" class="screen">
        <div id="mode-indicator">æš—è¨˜ãƒ¢ãƒ¼ãƒ‰</div>
        <div id="workspace-container">
            <div id="canvas-layer">
                <img id="base-image" src="" alt="">
                <div id="masks-container"></div>
            </div>
        </div>
        <div class="toolbar">
            <button class="tool-btn" onclick="App.goHome()">æˆ»ã‚‹</button>
            
            <div class="toolbar-center">
                <button class="tool-btn" id="btn-mode-switch" onclick="App.toggleMode()">ç·¨é›†ã™ã‚‹</button>
                
                <div id="edit-tools" style="display:none; gap:10px;">
                    <button class="tool-btn" id="btn-draw" onclick="App.toggleDrawMode()">ï¼‹ è¿½åŠ </button>
                    <button class="tool-btn danger" id="btn-delete" onclick="App.deleteSelectedMask()" disabled>å‰Šé™¤</button>
                </div>
            </div>
            
            <div style="width: 60px;"></div> </div>
    </div>

    <input type="file" id="file-input" accept="image/*">

<script>
if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('SW registered!', reg))
                .catch(err => console.log('SW failed', err));
        });
    }
/**
 * IndexedDB Wrapper
 */
const DB = {
    name: 'AnkiDB_v2', // ãƒãƒ¼ã‚¸ãƒ§ãƒ³å¤‰ãˆã¦ãŠã
    version: 1,
    db: null,
    
    init() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(this.name, this.version);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('sheets')) {
                    db.createObjectStore('sheets', { keyPath: 'id' });
                }
            };
            req.onsuccess = (e) => {
                this.db = e.target.result;
                resolve();
            };
            req.onerror = (e) => reject(e);
        });
    },
    getAll() {
        return new Promise((resolve) => {
            if(!this.db) return resolve([]);
            const tx = this.db.transaction('sheets', 'readonly');
            const req = tx.objectStore('sheets').getAll();
            req.onsuccess = () => resolve(req.result);
        });
    },
    save(data) {
        return new Promise((resolve) => {
            const tx = this.db.transaction('sheets', 'readwrite');
            tx.objectStore('sheets').put(data);
            tx.oncomplete = () => resolve();
        });
    },
    delete(id) {
        return new Promise((resolve) => {
            const tx = this.db.transaction('sheets', 'readwrite');
            tx.objectStore('sheets').delete(id);
            tx.oncomplete = () => resolve();
        });
    }
};

/**
 * Main Application Logic
 */
const App = {
    currentSheet: null,
    mode: 'play', 
    isDrawMode: false,
    
    // Transform state
    scale: 1,
    translateX: 0,
    translateY: 0,
    
    // Selection state
    selectedMaskIndex: -1,
    
    // Interaction state
    pointers: {}, 
    lastDist: 0,
    lastPoint: { x: 0, y: 0 },
    isDraggingCanvas: false,
    
    // Mask Manipulation state
    manipulationTarget: null, // 'move' or 'resize'
    manipulationStart: null,  // {x, y, initialMaskParams...}

    // Draw state
    drawStart: null,
    tempRect: null,

    async init() {
        await DB.init();
        this.renderLibrary();
        this.setupFileHandler();
        this.setupGestures();
    },

    // --- Library ---
    async renderLibrary() {
        const list = document.getElementById('library-list');
        list.innerHTML = '';
        const items = await DB.getAll();
        
        if (items.length === 0) {
            list.innerHTML = '<div style="text-align:center; padding:40px; color:#666;">å³ä¸Šã®ã€Œæ–°è¦ä½œæˆã€ã‹ã‚‰<br>ç”»åƒã‚’è¿½åŠ ã—ã¦ãã ã•ã„</div>';
            return;
        }

        items.sort((a,b) => b.id - a.id).forEach(item => {
            const div = document.createElement('div');
            div.className = 'lib-item';
            div.innerHTML = `
                <div class="lib-thumb" style="background-image: url('${item.image}')"></div>
                <div class="lib-info">
                    <span style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:80%;">${item.name}</span>
                    <button class="delete-btn" onclick="event.stopPropagation(); App.deleteSheet(${item.id})">ğŸ—‘</button>
                </div>
            `;
            div.onclick = () => this.openSheet(item);
            list.appendChild(div);
        });
    },

    setupFileHandler() {
        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (ev) => {
                const newSheet = {
                    id: Date.now(),
                    name: file.name,
                    image: ev.target.result,
                    masks: []
                };
                await DB.save(newSheet);
                this.openSheet(newSheet);
                this.renderLibrary();
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        });
    },

    async deleteSheet(id) {
        if(!confirm("ã“ã®ã‚·ãƒ¼ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return;
        await DB.delete(id);
        this.renderLibrary();
    },

    // --- Workspace ---
    openSheet(sheet) {
        this.currentSheet = sheet;
        document.getElementById('screen-library').classList.remove('active');
        document.getElementById('screen-workspace').classList.add('active');
        
        const img = document.getElementById('base-image');
        img.src = sheet.image;
        img.onload = () => {
            this.fitImage();
            this.setMode('play');
        };
    },

    fitImage() {
        const img = document.getElementById('base-image');
        const container = document.getElementById('workspace-container');
        if (!img.naturalWidth) return;

        const aspect = img.naturalWidth / img.naturalHeight;
        const containerAspect = container.clientWidth / container.clientHeight;
        
        this.scale = (aspect > containerAspect) 
            ? container.clientWidth / img.naturalWidth
            : container.clientHeight / img.naturalHeight;
            
        this.scale *= 0.95; // å°‘ã—ä½™ç™½
        this.translateX = (container.clientWidth - img.naturalWidth * this.scale) / 2;
        this.translateY = (container.clientHeight - img.naturalHeight * this.scale) / 2;
        this.updateTransform();
    },

    goHome() {
        this.saveCurrent();
        document.getElementById('screen-workspace').classList.remove('active');
        document.getElementById('screen-library').classList.add('active');
        this.renderLibrary();
    },

    async saveCurrent() {
        if (this.currentSheet) await DB.save(this.currentSheet);
    },

    // --- Mode Control ---
    toggleMode() {
        this.setMode(this.mode === 'play' ? 'edit' : 'play');
    },

    setMode(mode) {
        this.mode = mode;
        const btn = document.getElementById('btn-mode-switch');
        const tools = document.getElementById('edit-tools');
        const indicator = document.getElementById('mode-indicator');
        const container = document.getElementById('screen-workspace');

        container.classList.remove('mode-play', 'mode-edit');
        container.classList.add('mode-' + mode);

        if (mode === 'edit') {
            btn.innerText = "å®Œäº†";
            btn.classList.add('primary');
            tools.style.display = 'flex';
            indicator.innerText = "ç·¨é›†ãƒ¢ãƒ¼ãƒ‰";
            // åˆæœŸçŠ¶æ…‹ã§ã¯æç”»ãƒ¢ãƒ¼ãƒ‰OFFï¼ˆç§»å‹•/é¸æŠãƒ¢ãƒ¼ãƒ‰ï¼‰
            this.isDrawMode = false;
            document.getElementById('btn-draw').classList.remove('active');
        } else {
            btn.innerText = "ç·¨é›†ã™ã‚‹";
            btn.classList.remove('primary');
            tools.style.display = 'none';
            indicator.innerText = "æš—è¨˜ãƒ¢ãƒ¼ãƒ‰";
            this.selectedMaskIndex = -1; // é¸æŠè§£é™¤
            this.saveCurrent();
        }
        this.renderMasks();
        this.updateDeleteButton();
    },

    toggleDrawMode() {
        this.isDrawMode = !this.isDrawMode;
        const btn = document.getElementById('btn-draw');
        const indicator = document.getElementById('mode-indicator');
        
        // æç”»ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿æ™‚ã€é¸æŠã¯è§£é™¤
        this.selectedMaskIndex = -1;
        this.renderMasks();
        this.updateDeleteButton();

        if (this.isDrawMode) {
            btn.classList.add('active');
            indicator.innerText = "ç¯„å›²é¸æŠä¸­ (ãªãã£ã¦è¿½åŠ )";
        } else {
            btn.classList.remove('active');
            indicator.innerText = "ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ (ã‚¿ãƒƒãƒ—ã§é¸æŠãƒ»ç§»å‹•)";
        }
    },

    // --- Mask Rendering & Interaction ---
    renderMasks() {
        const container = document.getElementById('masks-container');
        container.innerHTML = '';
        
        this.currentSheet.masks.forEach((mask, index) => {
            const el = document.createElement('div');
            el.className = 'mask-rect';
            el.style.left = mask.x + 'px';
            el.style.top = mask.y + 'px';
            el.style.width = mask.w + 'px';
            el.style.height = mask.h + 'px';
            
            if (this.mode === 'play') {
                el.onclick = (e) => {
                    e.stopPropagation();
                    el.classList.toggle('revealed');
                };
            } else {
                // Edit Mode
                if (index === this.selectedMaskIndex) {
                    el.classList.add('selected');
                    // Add Resize Handle
                    const handle = document.createElement('div');
                    handle.className = 'resize-handle';
                    // Handle Interaction
                    handle.onpointerdown = (e) => this.startMaskManipulation(e, index, 'resize');
                    el.appendChild(handle);
                }
                
                // Mask Selection / Move Interaction
                el.onpointerdown = (e) => {
                    // ãƒãƒ³ãƒ‰ãƒ«ã§ã®ã‚¤ãƒ™ãƒ³ãƒˆãªã‚‰ãã¡ã‚‰å„ªå…ˆ
                    if(e.target.classList.contains('resize-handle')) return;
                    
                    if (this.selectedMaskIndex !== index) {
                        e.stopPropagation();
                        this.selectedMaskIndex = index;
                        this.renderMasks();
                        this.updateDeleteButton();
                    }
                    this.startMaskManipulation(e, index, 'move');
                };
            }
            container.appendChild(el);
        });
    },

    startMaskManipulation(e, index, type) {
        if(this.isDrawMode) return; // æç”»ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ç§»å‹•ç¦æ­¢
        e.stopPropagation(); // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒ‘ãƒ³ã‚’é˜»æ­¢
        e.preventDefault();

        this.manipulationTarget = type; // 'move' or 'resize'
        this.selectedMaskIndex = index; // å¿µã®ãŸã‚
        const mask = this.currentSheet.masks[index];
        
        this.manipulationStart = {
            pointerId: e.pointerId,
            startX: e.clientX,
            startY: e.clientY,
            initialX: mask.x,
            initialY: mask.y,
            initialW: mask.w,
            initialH: mask.h
        };
        
        // ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦ç”»é¢å¤–ã§ã‚‚ãƒ‰ãƒ©ãƒƒã‚°ç¶™ç¶š
        e.target.setPointerCapture(e.pointerId);
    },

    deleteSelectedMask() {
        if (this.selectedMaskIndex >= 0) {
            this.currentSheet.masks.splice(this.selectedMaskIndex, 1);
            this.selectedMaskIndex = -1;
            this.renderMasks();
            this.updateDeleteButton();
        }
    },
    
    updateDeleteButton() {
        const btn = document.getElementById('btn-delete');
        btn.disabled = (this.selectedMaskIndex === -1);
        btn.style.opacity = (this.selectedMaskIndex === -1) ? 0.5 : 1;
    },

    // --- Global Gesture Handling ---
    setupGestures() {
        const workspace = document.getElementById('workspace-container');
        workspace.addEventListener('pointerdown', (e) => this.onPointerDown(e));
        workspace.addEventListener('pointermove', (e) => this.onPointerMove(e));
        workspace.addEventListener('pointerup', (e) => this.onPointerUp(e));
        workspace.addEventListener('pointercancel', (e) => this.onPointerUp(e));
        
        workspace.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.applyZoom(delta, e.clientX, e.clientY);
        }, { passive: false });
    },

    onPointerDown(e) {
        // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚„æ—¢ã«å‡¦ç†ã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã¯ç„¡è¦–
        if (e.target.closest('.toolbar') || this.manipulationTarget) return;

        this.pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
        const keys = Object.keys(this.pointers);

        if (keys.length === 1) {
            if (this.mode === 'edit' && this.isDrawMode) {
                // Drawing Start
                const rect = document.getElementById('canvas-layer').getBoundingClientRect();
                this.drawStart = {
                    x: (e.clientX - rect.left) / this.scale,
                    y: (e.clientY - rect.top) / this.scale
                };
                this.tempRect = document.createElement('div');
                this.tempRect.className = 'mask-rect';
                this.tempRect.style.borderStyle = 'dashed';
                this.tempRect.style.background = 'rgba(255, 159, 10, 0.3)';
                document.getElementById('masks-container').appendChild(this.tempRect);
            } else {
                // Pan Start
                this.isDraggingCanvas = true;
                this.lastPoint = { x: e.clientX, y: e.clientY };
                
                // é¸æŠè§£é™¤ï¼ˆèƒŒæ™¯ã‚¿ãƒƒãƒ—æ™‚ï¼‰
                if (this.mode === 'edit' && !e.target.closest('.mask-rect')) {
                    this.selectedMaskIndex = -1;
                    this.renderMasks();
                    this.updateDeleteButton();
                }
            }
        } else if (keys.length === 2) {
            // Pinch Start
            this.isDraggingCanvas = false;
            this.drawStart = null;
            if(this.tempRect) { this.tempRect.remove(); this.tempRect = null; }
            
            const p1 = this.pointers[keys[0]];
            const p2 = this.pointers[keys[1]];
            this.lastDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            this.lastPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }
    },

    onPointerMove(e) {
        // 1. Mask Manipulation (Move/Resize)
        if (this.manipulationTarget && this.manipulationStart && e.pointerId === this.manipulationStart.pointerId) {
            const dx = (e.clientX - this.manipulationStart.startX) / this.scale;
            const dy = (e.clientY - this.manipulationStart.startY) / this.scale;
            const mask = this.currentSheet.masks[this.selectedMaskIndex];
            
            if (this.manipulationTarget === 'move') {
                mask.x = this.manipulationStart.initialX + dx;
                mask.y = this.manipulationStart.initialY + dy;
            } else if (this.manipulationTarget === 'resize') {
                const newW = Math.max(10, this.manipulationStart.initialW + dx);
                const newH = Math.max(10, this.manipulationStart.initialH + dy);
                mask.w = newW;
                mask.h = newH;
            }
            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ï¼ˆå…¨å†æç”»ã¯é‡ã„ã®ã§DOMç›´æ¥æ“ä½œãŒç†æƒ³ã ãŒã€å€‹æ•°å°‘ãªã„ã®ã§ç°¡æ˜“å®Ÿè£…ï¼‰
            this.renderMasks();
            return;
        }

        if (!this.pointers[e.pointerId]) return;
        this.pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
        const keys = Object.keys(this.pointers);

        // 2. Drawing
        if (this.drawStart && keys.length === 1) {
            const rect = document.getElementById('canvas-layer').getBoundingClientRect();
            const currX = (e.clientX - rect.left) / this.scale;
            const currY = (e.clientY - rect.top) / this.scale;

            const x = Math.min(this.drawStart.x, currX);
            const y = Math.min(this.drawStart.y, currY);
            const w = Math.abs(currX - this.drawStart.x);
            const h = Math.abs(currY - this.drawStart.y);

            this.tempRect.style.left = x + 'px';
            this.tempRect.style.top = y + 'px';
            this.tempRect.style.width = w + 'px';
            this.tempRect.style.height = h + 'px';
            return;
        }

        // 3. Pan / Zoom
        if (keys.length === 1 && this.isDraggingCanvas) {
            const dx = e.clientX - this.lastPoint.x;
            const dy = e.clientY - this.lastPoint.y;
            this.translateX += dx;
            this.translateY += dy;
            this.lastPoint = { x: e.clientX, y: e.clientY };
            this.updateTransform();
        } else if (keys.length === 2) {
            const p1 = this.pointers[keys[0]];
            const p2 = this.pointers[keys[1]];
            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const center = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };

            if (this.lastDist > 0) {
                const scaleDiff = dist / this.lastDist;
                const oldScale = this.scale;
                const newScale = oldScale * scaleDiff;
                
                if (newScale > 0.05 && newScale < 10) {
                    this.translateX = center.x - (center.x - this.translateX) * (newScale / oldScale);
                    this.translateY = center.y - (center.y - this.translateY) * (newScale / oldScale);
                    this.scale = newScale;
                }
                const dx = center.x - this.lastPoint.x;
                const dy = center.y - this.lastPoint.y;
                this.translateX += dx;
                this.translateY += dy;
                this.updateTransform();
            }
            this.lastDist = dist;
            this.lastPoint = center;
        }
    },

    onPointerUp(e) {
        // Manipulation End
        if (this.manipulationTarget && this.manipulationStart && e.pointerId === this.manipulationStart.pointerId) {
            this.manipulationTarget = null;
            this.manipulationStart = null;
            e.target.releasePointerCapture(e.pointerId);
            return;
        }

        delete this.pointers[e.pointerId];
        
        // Drawing End
        if (this.drawStart && Object.keys(this.pointers).length === 0) {
            if (this.tempRect) {
                const w = parseFloat(this.tempRect.style.width);
                const h = parseFloat(this.tempRect.style.height);
                if (w > 5 && h > 5) {
                    this.currentSheet.masks.push({
                        x: parseFloat(this.tempRect.style.left),
                        y: parseFloat(this.tempRect.style.top),
                        w: w, h: h
                    });
                    this.renderMasks();
                }
                this.tempRect.remove();
            }
            this.drawStart = null;
            this.tempRect = null;
        }

        if (Object.keys(this.pointers).length === 0) {
            this.isDraggingCanvas = false;
            this.lastDist = 0;
        }
    },

    applyZoom(factor, cx, cy) {
        const oldScale = this.scale;
        const newScale = oldScale * factor;
        if (newScale < 0.05 || newScale > 10) return;
        this.translateX = cx - (cx - this.translateX) * (newScale / oldScale);
        this.translateY = cy - (cy - this.translateY) * (newScale / oldScale);
        this.scale = newScale;
        this.updateTransform();
    },

    updateTransform() {
        const layer = document.getElementById('canvas-layer');
        layer.style.transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
    }
};

App.init();

</script>
</body>
</html>